---
applyTo: "**/*Mapstruct.java"
---

# MapStruct 编写规范

## 基本要求

- 所有类型转换映射器必须使用 MapStruct 框架
- Mapper 接口放在对应业务模块的 `mapstruct` 包下
- 使用 `@Mapper(componentModel = SPRING)` 注解，集成 Spring 容器
- Mapper 类命名遵循 `XxxMapstruct` 格式
- 必须添加完整的 JavaDoc 注释，说明转换目的和特殊逻辑

## 命名规范

### Mapper 接口命名

- **格式**: `{实体名}Mapstruct`
- **示例**: `BerryMapper`、`TypeMapper`、`PokemonMapper`
- **避免**: 与 MyBatis Mapper 命名冲突，使用完全限定类名或不同包结构

### 转换方法命名

- **格式**: `to{目标实体名}`
- **示例**: `toDatasetBerry`、`toDatasetType`
- **规则**: 方法名应清晰表达转换方向

### 自定义方法命名

- **格式**: `resolve{功能描述}`、`convert{功能描述}`、`extract{功能描述}`
- **示例**: `resolveLocalizedName`、`convertIdToLong`
- **规则**: 使用动词开头，清晰表达方法用途

## 注解使用

### @Mapper 注解

- **必须配置**: `componentModel = "spring"`
- **用途**: 使 Mapper 成为 Spring Bean，支持依赖注入

### @Mapping 注解

- **基本映射**: 用于字段名不同的情况
- **表达式映射**: 使用 `expression` 进行复杂类型转换
- **嵌套映射**: 使用点号表达式访问嵌套对象属性
- **自定义映射**: 使用 `qualifiedByName` 引用自定义转换方法

### @Named 注解

- **用途**: 标识自定义转换方法，供 `@Mapping` 引用
- **命名**: 使用驼峰命名，清晰表达转换逻辑

## 类名冲突处理

### 问题场景

当源类型和目标类型类名相同但包名不同时，需要避免导入冲突

### 解决方案

- **使用完全限定类名**: 在方法签名中使用完整包名
- **限制导入**: 只导入一个类，另一个使用完全限定名
- **推荐**: 目标类型（数据库实体）使用简单导入，源类型使用完全限定名

## 字段映射规则

### 简单字段映射

- **同名同类型**: 自动映射，无需配置
- **同名不同类型**: 需要表达式或自定义方法转换
- **不同名**: 使用 `@Mapping(target = "目标字段", source = "源字段")`

### 类型转换

- **基本类型转换**: 使用 `expression` 表达式
- **复杂对象转换**: 创建独立的转换方法
- **集合转换**: MapStruct 自动处理同类型集合映射

### 嵌套对象

- **点号访问**: `source = "对象.属性"`
- **多级嵌套**: `source = "对象.子对象.属性"`

## 自定义转换逻辑

### 使用场景

- 需要调用外部服务获取数据
- 需要复杂的业务逻辑处理
- 需要访问数据库或缓存
- 需要特殊的数据格式转换

### 实现方式

- 定义 `protected` 方法，使用 `@Named` 注解
- 方法可以注入 Spring Bean（通过 `@Autowired` 字段）
- 在 `@Mapping` 中使用 `qualifiedByName` 引用

### 注意事项

- 自定义方法应处理异常，提供默认值
- 避免在转换方法中执行耗时操作
- 考虑性能影响，必要时使用缓存

## 依赖注入

### 支持的方式

- 使用 `@Autowired` 注入 Spring Bean
- 注入的字段声明为 `protected`
- 可以注入 Service、Repository、工具类等

### 注意事项

- Mapper 必须声明为 `abstract class`（而非 `interface`）才能使用字段注入
- 转换方法仍声明为 `abstract`，由 MapStruct 生成实现
- 自定义方法声明为 `protected`，可以访问注入的依赖

## 性能考虑

### 编译时生成

- MapStruct 在编译时生成转换代码
- 生成的代码性能与手写代码相当
- 无反射开销

### 避免重复转换

- 合理设计转换方法，避免循环依赖
- 对于大量数据转换，考虑批量处理
- 必要时使用缓存优化性能

## 错误处理

### 空值处理

- MapStruct 默认处理 null 值
- 可以通过 `@Mapping` 配置忽略 null 值
- 自定义方法应检查 null 值

### 异常处理

- 自定义转换方法应捕获异常
- 提供合理的默认值或回退策略
- 记录错误日志，便于问题排查

## 集成使用

### 在 Service 中使用

- 通过构造器注入 Mapper
- 使用方法引用传递转换逻辑
- 保持 Service 代码简洁

### 批量转换

- 对于集合转换，直接定义 `List<Target> toXxxList(List<Source> sources)`
- MapStruct 自动处理集合元素的转换

## 测试建议

### 单元测试

- 为复杂的自定义转换方法编写单元测试
- 验证空值处理逻辑
- 验证异常处理逻辑

### 集成测试

- 在 Service 层集成测试中验证转换正确性
- 测试完整的数据流转换

## 最佳实践

1. **单一职责**: 每个 Mapper 只负责一种类型转换
2. **清晰命名**: 方法名清晰表达转换目的
3. **完整注释**: 说明转换逻辑和特殊处理
4. **异常处理**: 自定义方法必须处理异常
5. **性能优化**: 避免在转换中执行耗时操作
6. **可维护性**: 集中管理类型转换逻辑
7. **类型安全**: 利用编译时检查避免错误

## 维护建议

- 字段变更时同步更新映射配置
- 定期检查生成的代码是否符合预期
- 及时更新 MapStruct 版本获取新特性
- 为复杂转换添加详细的文档说明

